<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Nick Eales’ blog | Hoping to save someone some time (including myself)</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Nick Eales’ blog" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Hoping to save someone some time (including myself)" />
<meta property="og:description" content="Hoping to save someone some time (including myself)" />
<link rel="canonical" href="http://localhost:4000/Get_Private_Certificate_From_KeyVault.html" />
<meta property="og:url" content="http://localhost:4000/Get_Private_Certificate_From_KeyVault.html" />
<meta property="og:site_name" content="Nick Eales’ blog" />
<script type="application/ld+json">
{"@type":"WebPage","headline":"Nick Eales’ blog","url":"http://localhost:4000/Get_Private_Certificate_From_KeyVault.html","description":"Hoping to save someone some time (including myself)","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=933e36d4e6f3b8b4501aadae563ecd1d2366fb36">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">Nick Eales’ blog</a></h1>
      

      <p>Getting a certificate from key vault using PowerShell – while it isn’t obvious also isn’t hard. I’m putting this sample code here for me to use as a reference – but feel free to use &amp; adjust it as you want.</p>

<p>A few key points first about certificates in Key Vault.</p>
<ul>
  <li>BYO certificates when loaded into key vault are added using the <em>AzureKeyVaultCertificate</em> powershell cmdlets.
Key Vault can generate self-signed certificates using the New-AzureKeyVaultCertificatePolicy cmdlet with ‘-IssuerName Self’ and the Add-AzureKeyVaultCertificate cmdlet</li>
  <li>Private Certificates can then be accessed using the Get-AzureKeyVaultSecret cmdlet</li>
  <li>Public Certificates  can then be accessed using the Get-AzureKeyVaultKey cmdlet.</li>
  <li>Access to run each cmdlet is governed through a range of access policies. E.g. ‘Get’ rights on ‘secret’ objects lets you get a secret (e.g. by running Get-AzureKeyVaultSecret with ’-name’), and ‘List’ rights on ‘key’ objects lets you list the keys (e.g. by running Get-AzureKeyVaultKey without ’-name’).</li>
  <li>the below script assumes that you have authenticated to Key Vault and have permissions for the get operation.</li>
</ul>

<p>** NOTE - this method doesn’t work anymore</p>

<p>anyway.. some code to get private certificates and make them available for a few difference purposes (the main point of this post):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #get Secret object (Containing private key) from Key Vault
    $AzureKeyVaultSecret=Get-AzureKeyVaultSecret -VaultName $VaultName -Name $CertificateName -ErrorAction SilentlyContinue

    #Convert private cert to bytes
    $PrivateCertKVBytes = [System.Convert]::FromBase64String($AzureKeyVaultSecret.SecretValueText)

    #Convert Bytes to Certificate (flagged as exportable &amp; retaining private key)
    #possible flags: https://msdn.microsoft.com/en-us/library/system.security.cryptography.x509certificates.x509keystorageflags(v=vs.110).aspx
    $certObject = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2 -argumentlist $PrivateCertKVBytes,$null, "Exportable, PersistKeySet"


    #Optional: import certificate to current user Certificate store
    $Certificatestore = New-Object System.Security.Cryptography.X509Certificates.X509Store -argumentlist "My","Currentuser"
    $Certificatestore.open("readWrite")
    $Certificatestore.Add($certObject)
    $Certificatestore.Close()

    #if private certificate needs to be exported, then it needs a password - create Temporary Random Password for certificate
    $PasswordLength=20
    $ascii = 33..126 | %{[char][byte]$_}
    $CertificatePfxPassword = $(0..$passwordLength | %{$ascii | get-random}) -join ""
    # Alternative Method:
    $CertificatePfxPassword = [system.guid]::Newguid().ToString().Replace('-','').Trim(20)

    #Encrypt private Certificate using password (required if exporting to file or memory for use in ARM template)
    $protectedCertificateBytes = $certObject.Export([System.Security.Cryptography.X509Certificates.X509ContentType]::Pkcs12,
    $CertificatePfxPassword)
    Write-output "Private Certificate Password: '$CertificatePfxPassword'"

    #Optional: Export encrypted certificate to Base 64 String in memory (for use in ARM templates / other):
    $InternetPfxCertdata = [System.Convert]::ToBase64String($protectedCertificateBytes)

    #Optional: Export encrypted certificate to file on desktop:
    $pfxPath = '{0}\{1}.pfx' -f [Environment]::GetFolderPath("Desktop") ,$CertificateName
    [System.IO.File]::WriteAllBytes($pfxPath, $protectedCertificateBytes)
</code></pre></div></div>

<p>While the above example is for getting a private certificate, getting a public certificate is similar &amp; simpler. (use Get-AzureKeyVaultKey instead / a slight change to the flags if importing it locally / no need to encrypt if exporting to a .CER file).</p>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
